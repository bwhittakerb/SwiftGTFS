// The Swift Programming Language
// https://docs.swift.org/swift-book

import SQLite
import Foundation

let connectionPath = "/Users/brendan/Builds/data/gtfs/ets.db"

print("Hello, world!")
/*
do {
    let db = try Connection(connectionPath)

    let dateFormatter = DateFormatter()
    dateFormatter.dateFormat = "yyyyMMdd"
    dateFormatter.timeZone = TimeZone(identifier: "America/Edmonton")
    
    // last five minutes
    let fiveMinutesBefore = Calendar.current.date(byAdding: .minute, value: -5, to: Date())!

    // next x hours
    let showUntilTime = 2 //2 hours
    let untilTime = Calendar.current.date(byAdding: .hour, value: showUntilTime, to: Date())!
    
    // CURRENT STOPS
    let listOfStops: [String] = ["1688", "1392"]
    
    //time formatter
    let timeFormatter = DateFormatter()
    timeFormatter.timeZone = dateFormatter.timeZone
    timeFormatter.dateFormat = "HH:mm:ss"
    
    let trips = Table("trips")
    let stopTimes = Table("stop_times")
    let calendarDates = Table("calendar_dates")

    let arrivalTime = Expression<String>("arrival_time")
    let routeID = Expression<String>("route_id")
    let tripHeadsign = Expression<String>("trip_headsign")

    let tripID = Expression<String>("trip_id")
    let stopID = Expression<String>("stop_id")
    let serviceID = Expression<String>("service_id")
    let date = Expression<Int>("date")
    
    let validServiceIDsView = View("valid_service_ids")
      
    let createViewStatement = """
    CREATE TEMP VIEW valid_service_ids AS
           SELECT service_id, date
           FROM calendar_dates
           WHERE date == strftime('%Y%m%d', 'now', 'localtime')
              OR date == strftime('%Y%m%d', 'now', 'localtime', '+1 day');
    """

    try db.execute(createViewStatement)

    let fiveMinutesAgoStr = timeFormatter.string(from: fiveMinutesBefore)
    let untilTimeStr = timeFormatter.string(from: untilTime)

    // Execute the main query
    let nearbyStopsQuery = stopTimes
        .select(stopTimes[arrivalTime], trips[routeID], trips[tripHeadsign], stopID, date)
        .join(trips, on: stopTimes[tripID] == trips[tripID])
        .join(validServiceIDsView, on: trips[serviceID] == validServiceIDsView[serviceID])
        .where(listOfStops.contains(stopID))
//        .filter(stopTimes[arrivalTime] > fiveMinutesAgoStr &&
//                    stopTimes[arrivalTime] < untilTimeStr)
        .order(date.asc)
    
    for row in try db.prepare(nearbyStopsQuery) {
        let arrivalTime: String = row[arrivalTime]
        let routeId: String = row[routeID]
        let headsign: String = row[tripHeadsign]
        let stopId: String = row[stopID]
        let arriveDate: Int = row[date]
        print("Stop: \(stopId), \(headsign). Time: \(arriveDate) \(arrivalTime)")
        // Use the row data as needed
    }
        
    
    
} catch {
    print(error)
}
 */

struct NearbyBusses {
    let atTime: Date
    let coordinates: Coordinates
    let stops: [String] = ["default"]
    var stopArrivalsList: [StopArrivals] = [StopArrivals(stop: "blah", stopName: "blahblah", stopCoords: Coordinates(lat: 1.1, long: 2.2), Arrivals: [Arrival(routeID: "blah", arrivalTime: Date(), headSign: "heady")])]
    
    init?(atTime: Date = Date(), latitude: Double, longitude: Double, radiusInKM: Double = 0.25, timeWindow: Double = 2) {
        self.atTime = atTime
        self.coordinates = Coordinates(lat: latitude, long: longitude)
        guard let unwrappedStopList = deriveStopList(coordinates: self.coordinates, radiusInKM: radiusInKM, timeWindow: timeWindow) else {
            return nil // change this to something like a blank list
        }
        print("sup")
//        self.stops =
        self.stopArrivalsList = unwrappedStopList
    }
    
    public func deriveStopList(coordinates: Coordinates, radiusInKM: Double, timeWindow: Double) -> [StopArrivals]? {
        do {
            let db = try Connection(connectionPath)
            
            let stopsTable = Table("stops")
            let trips = Table("trips")
            let stopTimes = Table("stop_times")
            let calendarDates = Table("calendar_dates")
            let validServiceIDsView = View("valid_service_ids")
            
            let stopLat = Expression<Double>("stop_lat")
            let stopLon = Expression<Double>("stop_lon")
            let date = Expression<Int>("date")
            let stopID = Expression<String>("stop_id")
            let stopName = Expression<String>("stop_name")
            let arrivalTime = Expression<String>("arrival_time")
            let routeID = Expression<String>("route_id")
            let tripHeadsign = Expression<String>("trip_headsign")
            let tripID = Expression<String>("trip_id")
            let serviceID = Expression<String>("service_id")
            
            
            // //////DATE STUFF
            enum DateError: Error {
                case invalidDateFormat
            }
            let dateFormatter = DateFormatter()
            dateFormatter.dateFormat = "yyyyMMdd"
            dateFormatter.timeZone = TimeZone(identifier: "America/Edmonton")
            //time formatter
            let timeFormatter = DateFormatter()
            timeFormatter.timeZone = dateFormatter.timeZone
            timeFormatter.dateFormat = "HH:mm:ss"
            //datetime formatter
            let dateTimeFormatter = DateFormatter()
            dateTimeFormatter.dateFormat = "yyyyMMdd HH:mm:ss"
            dateTimeFormatter.timeZone = dateFormatter.timeZone
            
            // last five minutes
            let fiveMinutesBefore = Calendar.current.date(byAdding: .minute, value: -5, to: Date())!

            // next x hours
            let showUntilTime = 2 //2 hours
            let untilTime = Calendar.current.date(byAdding: .hour, value: showUntilTime, to: Date())!
            // //////ENDDATE STUFF
            
            let tempValidServiceView = """
            CREATE TEMP VIEW valid_service_ids AS
                   SELECT service_id, date
                   FROM calendar_dates
                   WHERE date == strftime('%Y%m%d', 'now', 'localtime')
                      OR date == strftime('%Y%m%d', 'now', 'localtime', '+1 day');
            """
            
            try db.execute(tempValidServiceView)
            
            if let listOfStops = returnStops(coordinates: coordinates, radiusInKM: radiusInKM) {
                
                let nearbyStopsQuery = stopTimes
                    .select(stopTimes[arrivalTime], trips[routeID], trips[tripHeadsign], stopTimes[stopID], date, stopsTable[stopLat], stopsTable[stopLon], stopsTable[stopName])
                    .join(trips, on: stopTimes[tripID] == trips[tripID])
                    .join(validServiceIDsView, on: trips[serviceID] == validServiceIDsView[serviceID])
                    .join(stopsTable, on: stopTimes[stopID] == stopsTable[stopID])
                    .where(listOfStops.contains(stopTimes[stopID]))
                
                let nearbyStopsBussesQuery = stopTimes
                    .select(stopTimes[arrivalTime], trips[routeID], trips[tripHeadsign], stopTimes[stopID], date, stopsTable[stopLat], stopsTable[stopLon])
                    .join(trips, on: stopTimes[tripID] == trips[tripID])
                    .join(validServiceIDsView, on: trips[serviceID] == validServiceIDsView[serviceID])
                    .join(stopsTable, on: stopTimes[stopID] == stopsTable[stopID])
                
            var listOfStopArrivals: [StopArrivals] = []
                               
                for row in try db.prepare(nearbyStopsQuery) {
                    
                    func parseDateAndTime(dateString: String, timeString: String) throws -> Date {
                        // Try to parse normally first
                        if let date = dateTimeFormatter.date(from: "\(dateString) \(timeString)") {
                            return date
                        }
                        
                        // Handles time that overflows past midnight, i.e. "26:31:00"
                        func timeIntervalFromString(_ timeString: String) -> TimeInterval? {
                            let components = timeString.split(separator: ":").map(String.init)
                            guard components.count == 3,
                                  let hours = Int(components[0]),
                                  let minutes = Int(components[1]),
                                  let seconds = Int(components[2]) else {
                                return nil
                            }
                            return TimeInterval(hours * 3600 + minutes * 60 + seconds)
                        }
                        
                        print("Odd time: \(dateString) \(timeString)")
                        
                        let formatter = DateComponentsFormatter()
                        formatter.allowedUnits = [.hour, .minute, .second]
                        formatter.unitsStyle = .positional
                        formatter.zeroFormattingBehavior = .pad
                        
                        guard let duration = timeIntervalFromString(timeString) else {
                            throw DateError.invalidDateFormat
                        }
                        
                        // Adjust for overflow past midnight
                        // Example subtracting 24 hours worth of seconds from time:
                        
                        let subtractedDuration = duration - (24 * 60 * 60)
                        
                        guard let formattedCorrectedTime = formatter.string(from: subtractedDuration) else {throw DateError.invalidDateFormat}
                        
                        guard let arrivalDateTime = dateTimeFormatter.date(from: "\(dateString) \(formattedCorrectedTime)")?.addingTimeInterval(24*60*60) else {
                            throw DateError.invalidDateFormat
                        }
//                        let edmtimezone = TimeZone(identifier: "America/Edmonton")
                        print("corrected date is \(DateFormatter.localizedString(from: arrivalDateTime, dateStyle: .short, timeStyle: .medium)) ")
                        return arrivalDateTime
                    }
                    
                    do {
//                        let arrivalDateTime = try parseDateAndTime(dateString: "\(row[date])", timeString: row[arrivalTime])
//                            
//                                               
//                        let lastTenMinutes: TimeInterval = -600 // 60 seconds/minute * 10 minutes
//                        let nextHours: TimeInterval = timeWindow
//                        
//                        if arrivalDateTime.timeIntervalSinceNow >= lastTenMinutes &&
//                            arrivalDateTime.timeIntervalSinceNow <= nextHours {
                            
                          print("now doing stop: \(row[stopID])")

                        var listOfArrivals: [Arrival] = []
                        print(listOfArrivals)
                            for arrival in try db.prepare(nearbyStopsBussesQuery
                                .where(stopTimes[stopID] == row[stopID])) {
                                print("StopID: \(arrival[stopID])")
                                let testArrival: Arrival = try Arrival(routeID: arrival[routeID], arrivalTime: parseDateAndTime(dateString: String(arrival[date]), timeString: arrival[arrivalTime]), headSign: arrival[tripHeadsign])
//                                print(testArrival)
                                let lastFiveMinutes = Date().addingTimeInterval(-500)
                                let nextHours = Date().addingTimeInterval(timeWindow * 60 * 60) //multiply hours by minutes * seconds
                                print(testArrival.arrivalTime)
                                if testArrival.arrivalTime >= lastFiveMinutes && testArrival.arrivalTime <= nextHours {
                                    print(testArrival.arrivalTime.description, "is within \(Date().description)")
                                    listOfArrivals.append(testArrival)
                                }
                            
                            
                        }
                        listOfStopArrivals.append(StopArrivals(stop: row[stopID], stopName: row[stopName], stopCoords: Coordinates(lat: row[stopLat], long: row[stopLon]), Arrivals: listOfArrivals))
                        print(listOfArrivals)
                        
                    } catch {
                        print("Error: \(error)")
                    }
                    
                    
                    let arrivalTime: String = row[arrivalTime]
                    let routeId: String = row[routeID]
                    let headsign: String = row[tripHeadsign]
                    let stopId: String = row[stopID]
                    let arriveDate: Int = row[date]
//                    print("Stop: \(stopId), \(headsign). Time: \(arriveDate) \(arrivalTime)")
                    
                }
                
            } else {return nil}
            
            func returnStops(coordinates: Coordinates, radiusInKM: Double) -> [String]? {
                
                var returnStops: [String] = []
                
                do {
                    for stop in try db.prepare(stopsTable) {
                        let distance = getDistance(origin: coordinates, point: Coordinates(lat: stop[stopLat], long: stop[stopLon]))
                        
                        if distance <= radiusInKM {
                            returnStops.append(stop[stopID])
                        }
                    }
                } catch {print(error)}
                return returnStops
            }
                

                
                //                        StopArrivals(stop: stop[stopID],
                //                                    stopName: stop[stopName],
                //                                    stopCoords: Coordinates(lat: stop[stopLat], long: stop[stopLon]),
                //                                    Arrivals: <#T##[Arrival]#>)
//                if let unwrappedStops = returnStops {
//                    try db.execute(tempArrivalsView)
//                }

            
//            return returnStops
        } catch {
            print(error)
        }
        
        return nil
    }
    
    public func getDistance(origin: Coordinates, point: Coordinates) -> Double {
        let earthRadius: Double = 6371
        let halfPi = Double.pi / 180
        
        let coordDistance = 0.5 - cos((point.lat - origin.lat) * halfPi) / 2 +
                            cos(origin.lat * halfPi) * cos(point.lat * halfPi) *
                            (1 - cos((point.long - origin.long) * halfPi)) / 2
        
        let result = 2.0 * earthRadius * asin(sqrt(coordDistance))
        
        return result
        
    }
}

struct StopArrivals {
    let stop: String
    let stopName: String
    let stopCoords: Coordinates
    let Arrivals: [Arrival]
}

struct Arrival {
    let routeID: String
    let arrivalTime: Date
    let headSign: String
}

struct Coordinates {
    let lat: Double
    let long: Double
}


let mainStruct = NearbyBusses(latitude: 53.54092272954773, longitude: -113.52495148525607)
